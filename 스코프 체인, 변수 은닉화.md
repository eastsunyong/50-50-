### **스코프 체인, 변수 은닉화**

스코프란 ?

scope의 사전적인 의미는 **범위이다**. 자바스크립트에서 스코프란 작성된 코드를 둘러싼 환경으로, 어떤 변수들에 접근할 수 있는지를 정의한다. 어떤 범위 내에 속해있는지를 정의한다고 생각하면 사전적 의미와 유사하다고 할 수 있다. 스코프는 **전역**(global)과 **지역**(local) 스코프로 정의할 수 있다.

**전역 스코프**는 함수 안에 포함되지 않은 곳에 정의하는 것으로 코드 어디에서든지 참조할 수 있고, **지역 스코프**는 함수 내에 정의된 것으로 정의된 함수 내에서만 참조할 수 있다. 이 개념은 다른 프로그래밍 언어를 하신 적이 있는 사람들 이라면 지역변수와 전역변수를 배울 때 비슷하게 들어봤을 것 이다. 하지만 자바스크립트의 스코프는 다른 언어와 다른 특징을 가지고 있는데, 바로 자바스크립트는 Function-level scope(함수 레벨 스코프)를 사용한다는 것이다. 대부분의 언어는 Block-level scope(블록 레벨 스코프)를 사용함으로써, 변수 선언이 코드 블록 단위로 유효한다. 하지만 Function-level scope인 자바스크립트는 함수 블록 내에서 선언된 변수는 함수 블록 내에서만 유효하고 함수 외부에서는 참조할 수 없다.

### **렉시컬 스코프란(Lexical Scope)란?**

함수를 어디서 호출하는지가 아니라 어디에 **선언하였는지에 따라 결정되는 것**을 말한다.

즉, 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정한다는 뜻이며, 가장 중요한 점은 함수의 호출이 아니라 **함수의 선언에 따라 결정된다는 점**이다.

다른 말로, **정적 스코프(Static scope)**라 부르기도 하다.

### **클로저(Closure)**

함수 + 함수를 둘러싼 환경(Lexical environment)

함수를 둘러싼 환경이라는 것이 바로 앞에서 설명했던 렉시컬 스코프다.함수를 만들고 그 함수 내부의 코드가 탐색하는 스코프를 함수 생성 당시의 렉시컬 스코프로 고정하면 바로 클로저가 되는 것이다

### 자바스크립트의 클로저

자바스크립트에서 클로저는 함수가 생성되는 시점에 생성된다.= 함수가 생성될 때 그 함수의 렉시컬 환경을 포섭(closure)하여 실행될 때 이용한다

어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상을 말한다.

```jsx
const A = function () {
	let a = 1;
    const B = function () {
    	return ++a;
    }
    return B;
  };

const copyA = A();

for (let i = 0; i < 3; i++) {
 console.log(copyA());// 2 3 4
}
```

a의 값이 계속 남아 2 3 4처럼 하나씩 증가 되는 값을 console log를 통해 확인 할 수 있었다.

예제를 확인해보면 내부함수를 외부로 전달 하였을 때 컨텍스트가 종료 된 이후에도 변수는 사라지지 않는 것을 보여준다. 왜냐하면 copyA가 A함수를 호출하면서 내부함수 B를 참조하게 되었기 때문이다.

GC 특성 상 더이상 사용하지 않는 변수를 수거하지만 copyA가 B를 참조하면서 B내부에 있는 a 변수를 계속해서 참조를 하게 되었다. 그로인해 A함수 실행 완료 후 A함수가 실행컨텍스트에서 제거 되어야하지만 변수 a를 사용한 B 함수에 의해 A 함수의 변수 a는 제거되지 않고 남아있게 된다.

클로저의 개념을 다시 설명하게 되면 내부함수 B가 Lexical Environment(자신이 실행되었을 때의 환경)를 기억하는 함수이다.

# 은닉화

```jsx
(function s(){
let a = 'hi'
})()//a is not defined
```

이러한 방식과 같이 **직접적으로 변경되면 안 되는 변수에 대한 접근을 막는 것**을 은닉화라고 한다.

```jsx
function hello(name) {
  let _name = name;
  return function () {
    console.log('Hello, ' + _name);
  };
}

let a = new hello('영서');
let b = new hello('아름');

a()//Hello, 영서
b()//Hello, 아름
```

이렇게 a와 b라는 클로저를 생성함으로써 함수 내부적으로 접근이 가능하다.

```jsx
function a(){
  let temp = 'a'

  return temp;
}

// console.log(temp)  error: temp is not definedconst result = a()
console.log(result);//a
```

위 함수 내부적으로 선언된 temp에는 직접적으로 접근을 할 수 없습니다. 함수 a를 실행시켜 그 값을 result라는 변수에 담아 클로저를 생성함으로써 temp의 값에 접근이 가능합니다.
